{
  "version": "1.0",
  "cells": [
    {
      "type": "markdown",
      "content": "# Multiclass Classification\n\nIn the last notebook, we looked at binary classification. This works well when the data observations belong to one of two classes or categories, such as \"True\" or \"False\". When the data is categorized into more than two classes, you'll need a multiclass classification algorithm.\n\nMulticlass classification can be a combination of multiple binary classifiers. There are two ways to approach this problem:\n\n- **One vs Rest (OVR)**, in which a classifier is created for each possible class value, with a positive outcome for cases where the prediction is *this* class, and negative predictions for cases where the prediction is any other class. A classification problem with four possible shape classes (*square*, *circle*, *triangle*, *hexagon*) would require four classifiers that predict:\n    - *square* or not\n    - *circle* or not\n    - *triangle* or not\n    - *hexagon* or not\n    \n- **One vs One (OVO)**, in which a classifier for each possible pair of classes is created. The classification problem with four shape classes would require the following binary classifiers:\n    - *square* or *circle*\n    - *square* or *triangle*\n    - *square* or *hexagon*\n    - *circle* or *triangle*\n    - *circle* or *hexagon*\n    - *triangle* or *hexagon*\n\nIn both approaches, the overall model that combines the classifiers generates a vector of predictions, in which the probabilities generated from the individual binary classifiers are used to determine which class to predict.\n\nFortunately, in most machine learning frameworks, including Scikit-Learn, implementing a multiclass classification model is not significantly more complex than binary classification - and in most cases, the estimators used for binary classification implicitly support multiclass classification by abstracting an OVR algorithm, an OVO algorithm, or by allowing a choice of either.\n\n> **Citation**: The penguins dataset used in the this exercise is a subset of data collected and made available by [Dr.Â Kristen Gorman](https://www.uaf.edu/cfos/people/faculty/detail/kristen-gorman.php) and the [Palmer Station, Antarctica LTER](https://lternet.edu/site/palmer-antarctica-lter), a member of the [Long Term Ecological Research Network](https://lternet.edu).\n\n**Explore the data**\n\nLet's start by examining a dataset that contains observations of multiple classes. We'll use a dataset that contains observations of three different species of penguin.\n\n1. Download [penguins.csv](https://raw.githubusercontent.com/MicrosoftLearning/mslearn-ml-basics/refs/heads/main/Labfiles/data/penguins.csv){:target=\"_blank\"} in a new browser tab, and save it on your local disk.\n2. Then use the **Upload Data** button at the top of this notebook to upload it.\n3. Run the next cell by clicking the **&#9658; Run** button to load the data and train a classification model."
    },
    {
      "type": "python",
      "content": "import pandas as pd\n\n# load the training dataset\npenguins = pd.read_csv('penguins.csv')\n\n# Display a random sample of 10 observations\nsample = penguins.sample(10)\nprint(sample)"
    },
    {
      "type": "markdown",
      "content": "The dataset contains the following columns:\n* **CulmenLength**: The length in mm of the penguin's culmen (bill).\n* **CulmenDepth**: The depth in mm of the penguin's culmen.\n* **FlipperLength**: The length in mm of the penguin's flipper.\n* **BodyMass**: The body mass of the penguin in grams.\n* **Species**: An integer value that represents the species of the penguin.\n\nThe **Species** column is the label we want to train a model to predict. The dataset includes three possible species, which are encoded as 0, 1, and 2. The actual species names are revealed by the code below:"
    },
    {
      "type": "python",
      "content": "penguin_classes = ['Adelie', 'Gentoo', 'Chinstrap']\nprint(sample.columns[0:5].values, 'SpeciesName')\nfor index, row in penguins.sample(10).iterrows():\n    print('[', row[0], row[1], row[2], row[3], int(row[4]),']', penguin_classes[int(row[4])])"
    },
    {
      "type": "markdown",
      "content": "Now that we know what the features and labels in the data represent, let's explore the dataset. First, let's see if there are any missing (*null*) values."
    },
    {
      "type": "python",
      "content": "# Count the number of null values for each column\nprint(penguins.isnull().sum())"
    },
    {
      "type": "markdown",
      "content": "It looks like there are some missing feature values, but no missing labels. Let's dig a little deeper and see the rows that contain nulls."
    },
    {
      "type": "python",
      "content": "# Show rows containing nulls\nprint(penguins[penguins.isnull().any(axis=1)])"
    },
    {
      "type": "markdown",
      "content": "There are two rows that contain no feature values at all (*NaN* means \"not a number\"), so these won't be useful in training a model. Let's discard them from the dataset."
    },
    {
      "type": "python",
      "content": "# Drop rows containing NaN values\npenguins=penguins.dropna()\n#Confirm there are now no nulls\nprint(penguins.isnull().sum())\n"
    },
    {
      "type": "markdown",
      "content": "Now that we've dealt with the missing values, let's explore how the features relate to the label by creating some box charts."
    },
    {
      "type": "python",
      "content": "from matplotlib import pyplot as plt\n\npenguin_features = ['CulmenLength','CulmenDepth','FlipperLength','BodyMass']\npenguin_label = 'Species'\nfor col in penguin_features:\n    penguins.boxplot(column=col, by=penguin_label, figsize=(6,6))\n    plt.title(col)\nplt.show()"
    },
    {
      "type": "markdown",
      "content": "From the box plots, it looks like species 0 and 2 (Adelie and Chinstrap) have similar data profiles for culmen depth, flipper length, and body mass, but Chinstraps tend to have longer culmens. Species 1 (Gentoo) tends to have fairly clearly differentiated features from the others, which should help us train a good classification model.\n\n### Prepare the data\n\nJust as for binary classification, before training the model, we need to separate the features and label, and then split the data into subsets for training and validation. We'll also apply a *stratification* technique when splitting the data to maintain the proportion of each label value in the training and validation datasets."
    },
    {
      "type": "python",
      "content": "from sklearn.model_selection import train_test_split\n\n# Separate features and labels\npenguins_X, penguins_y = penguins[penguin_features].values, penguins[penguin_label].values\n\n# Split data 70%-30% into training set and test set\nx_penguin_train, x_penguin_test, y_penguin_train, y_penguin_test = train_test_split(penguins_X, penguins_y,\n                                                                                    test_size=0.30,\n                                                                                    random_state=0,\n                                                                                    stratify=penguins_y)\n\nprint ('Training Set: %d, Test Set: %d \\n' % (x_penguin_train.shape[0], x_penguin_test.shape[0]))"
    },
    {
      "type": "markdown",
      "content": "### Train and evaluate a multiclass classifier\n\nNow that we have a set of training features and corresponding training labels, we can fit a multiclass classification algorithm to the data to create a model. Most Scikit-Learn classification algorithms inherently support multiclass classification. We'll try a logistic regression algorithm."
    },
    {
      "type": "python",
      "content": "from sklearn.linear_model import LogisticRegression\n\n# Set regularization rate\nreg = 0.1\n\n# train a logistic regression model on the training set\nmulti_model = LogisticRegression(C=1/reg, solver='lbfgs', multi_class='auto', max_iter=10000).fit(x_penguin_train, y_penguin_train)\nprint (multi_model)"
    },
    {
      "type": "markdown",
      "content": "Now we can use the trained model to predict the labels for the test features, and compare the predicted labels to the actual labels."
    },
    {
      "type": "python",
      "content": "penguin_predictions = multi_model.predict(x_penguin_test)\nprint('Predicted labels: ', penguin_predictions[:15])\nprint('Actual labels   : ', y_penguin_test[:15])"
    },
    {
      "type": "markdown",
      "content": "Let's look at a classification report."
    },
    {
      "type": "python",
      "content": "from sklearn. metrics import classification_report\n\nprint(classification_report(y_penguin_test, penguin_predictions))"
    },
    {
      "type": "markdown",
      "content": "As with binary classification, the report includes *precision* and *recall* metrics for each class. However, while with binary classification we could focus on the scores for the *positive* class; in this case, there are multiple classes so we need to look at an overall metric (either the macro or weighted average) to get a sense of how well the model performs across all three classes.\n\nYou can get the overall metrics separately from the report using the Scikit-Learn metrics score classes, but with multiclass results you must specify which average metric to use for precision and recall."
    },
    {
      "type": "python",
      "content": "from sklearn.metrics import accuracy_score, precision_score, recall_score\n\nprint(\"Overall Accuracy:\",accuracy_score(y_penguin_test, penguin_predictions))\nprint(\"Overall Precision:\",precision_score(y_penguin_test, penguin_predictions, average='macro'))\nprint(\"Overall Recall:\",recall_score(y_penguin_test, penguin_predictions, average='macro'))"
    },
    {
      "type": "markdown",
      "content": "Now let's look at the confusion matrix for our model."
    },
    {
      "type": "python",
      "content": "from sklearn.metrics import confusion_matrix\n\n# Print the confusion matrix\nmcm = confusion_matrix(y_penguin_test, penguin_predictions)\nprint(mcm)"
    },
    {
      "type": "markdown",
      "content": "The confusion matrix shows the intersection of predicted and actual label values for each class, where the diagonal intersections from top-left to bottom-right indicate the number of correct predictions.\n\nWhen dealing with multiple classes, it's generally more intuitive to visualize this as a heat map."
    },
    {
      "type": "python",
      "content": "import numpy as np\nimport matplotlib.pyplot as plt\n\nplt.imshow(mcm, interpolation=\"nearest\", cmap=plt.cm.Blues)\nplt.colorbar()\ntick_marks = np.arange(len(penguin_classes))\nplt.xticks(tick_marks, penguin_classes, rotation=45)\nplt.yticks(tick_marks, penguin_classes)\nplt.xlabel(\"Predicted Species\")\nplt.ylabel(\"Actual Species\")\nplt.show()"
    },
    {
      "type": "markdown",
      "content": "The darker squares in the confusion matrix plot indicate high numbers of cases, and you can hopefully see a diagonal line of darker squares indicating cases where the predicted and actual label are the same.\n\nIn the case of a multiclass classification model, a single ROC curve showing true positive rate vs false positive rate is not possible. However, you can use the rates for each class in a One vs Rest (OVR) comparison to create a ROC chart for each class."
    },
    {
      "type": "python",
      "content": "from sklearn.metrics import roc_curve\nfrom sklearn.metrics import roc_auc_score\n\n# Get class probability scores\npenguin_prob = multi_model.predict_proba(x_penguin_test)\n\n# Get ROC metrics for each class\nfpr = {}\ntpr = {}\nthresh ={}\nfor i in range(len(penguin_classes)):    \n    fpr[i], tpr[i], thresh[i] = roc_curve(y_penguin_test, penguin_prob[:,i], pos_label=i)\n    \n# Plot the ROC chart\nplt.plot(fpr[0], tpr[0], linestyle='--',color='orange', label=penguin_classes[0] + ' vs Rest')\nplt.plot(fpr[1], tpr[1], linestyle='--',color='green', label=penguin_classes[1] + ' vs Rest')\nplt.plot(fpr[2], tpr[2], linestyle='--',color='blue', label=penguin_classes[2] + ' vs Rest')\nplt.title('Multiclass ROC curve')\nplt.xlabel('False Positive Rate')\nplt.ylabel('True Positive rate')\nplt.legend(loc='best')\nplt.show()"
    },
    {
      "type": "markdown",
      "content": "To quantify the ROC performance, you can calculate an aggregate area under the curve score that is averaged across all of the OVR curves."
    },
    {
      "type": "python",
      "content": "auc = roc_auc_score(y_penguin_test,penguin_prob, multi_class='ovr')\nprint('Average AUC:', auc)"
    },
    {
      "type": "markdown",
      "content": "### Preprocess data in a pipeline\n\nAgain, just like with binary classification, you can use a pipeline to apply preprocessing steps to the data before fitting it to an algorithm to train a model. Let's see if we can improve the penguin predictor by scaling the numeric features in a transformation step before training. We'll also try a different algorithm, a *support vector machine*, just to show that we can."
    },
    {
      "type": "python",
      "content": "from sklearn.preprocessing import StandardScaler\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.svm import SVC\n\n# Define preprocessing for numeric columns (scale them)\nfeature_columns = [0,1,2,3]\nfeature_transformer = Pipeline(steps=[\n    ('scaler', StandardScaler())\n    ])\n\n# Create preprocessing steps\npreprocessor = ColumnTransformer(\n    transformers=[\n        ('preprocess', feature_transformer, feature_columns)])\n\n# Create training pipeline\npipeline = Pipeline(steps=[('preprocessor', preprocessor),\n                           ('regressor', SVC(probability=True))])\n\n\n# fit the pipeline to train a linear regression model on the training set\nmulti_model = pipeline.fit(x_penguin_train, y_penguin_train)\nprint (multi_model)"
    },
    {
      "type": "markdown",
      "content": "Now let's evaluate the new model."
    },
    {
      "type": "python",
      "content": "# Get predictions from test data\npenguin_predictions = multi_model.predict(x_penguin_test)\npenguin_prob = multi_model.predict_proba(x_penguin_test)\n\n# Overall metrics\nprint(\"Overall Accuracy:\", accuracy_score(y_penguin_test, penguin_predictions))\nprint(\"Overall Precision:\", precision_score(y_penguin_test, penguin_predictions, average='macro'))\nprint(\"Overall Recall:\", recall_score(y_penguin_test, penguin_predictions, average='macro'))\nprint('Average AUC:', roc_auc_score(y_penguin_test,penguin_prob, multi_class='ovr'))\n\n# Confusion matrix\nplt.imshow(mcm, interpolation=\"nearest\", cmap=plt.cm.Blues)\nplt.colorbar()\ntick_marks = np.arange(len(penguin_classes))\nplt.xticks(tick_marks, penguin_classes, rotation=45)\nplt.yticks(tick_marks, penguin_classes)\nplt.xlabel(\"Predicted Species\")\nplt.ylabel(\"Actual Species\")\nplt.show()"
    },
    {
      "type": "markdown",
      "content": "### Use the model with new data observations\n\nSave our newest trained model so we can use it again later."
    },
    {
      "type": "python",
      "content": "import joblib\n\n# Save the model as a pickle file\nfilename = './penguin_model.pkl'\njoblib.dump(multi_model, filename)"
    },
    {
      "type": "markdown",
      "content": "Now let's use the model to predict the class of a new penguin observation."
    },
    {
      "type": "python",
      "content": "# Load the model from the file\nmulti_model = joblib.load(filename)\n\n# The model accepts an array of feature arrays (so you can predict the classes of multiple penguin observations in a single call)\n# We'll create an array with a single array of features, representing one penguin\nx_new = np.array([[50.4,15.3,224,5550]])\nprint ('New sample: {}'.format(x_new[0]))\n\n# The model returns an array of predictions - one for each set of features submitted\n# In our case, we only submitted one penguin, so our prediction is the first one in the resulting array.\npenguin_pred = multi_model.predict(x_new)[0]\nprint('Predicted class is', penguin_classes[penguin_pred])"
    },
    {
      "type": "markdown",
      "content": "You can also submit a batch of penguin observations to the model, and get back a prediction for each one."
    },
    {
      "type": "python",
      "content": "# This time our input is an array of two feature arrays\nx_new = np.array([[49.5,18.4,195, 3600],\n         [38.2,20.1,190,3900]])\nprint ('New samples:\\n{}'.format(x_new))\n\n# Call the web service, passing the input data\npredictions = multi_model.predict(x_new)\n\n# Get the predicted classes.\nfor prediction in predictions:\n    print(prediction, '(' + penguin_classes[prediction] +')')"
    },
    {
      "type": "markdown",
      "content": "## Summary\n\nClassification is one of the most common forms of machine learning, and by following the basic principles we've discussed in this notebook you should be able to train and evaluate classification models with Scikit-Learn. It's worth spending some time investigating classification algorithms in more depth, and a good starting point is the [Scikit-Learn documentation](https://scikit-learn.org/stable/user_guide.html)."
    }
  ]
}